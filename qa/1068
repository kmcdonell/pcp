#!/bin/sh
# PCP QA Test No. 1068
# Exercise pcp2zabbix.
#
# Copyright (c) 2015-2018 Red Hat.
#

seq=`basename $0`
echo "QA output created by $seq"

. ./common.python

$python -c "from pcp import pmapi" >/dev/null 2>&1
[ $? -eq 0 ] || _notrun "python pcp pmapi module not installed"
$python -c "from collections import OrderedDict" >/dev/null 2>&1
[ $? -eq 0 ] || _notrun "python collections OrderedDict module not installed"

which socat >/dev/null 2>&1 || _notrun "socat binary not installed"
which pcp2zabbix >/dev/null 2>&1 || _notrun "pcp2zabbix not installed"
vis=cat
which vis >/dev/null 2>&1 && vis=vis

status=1	# failure is the default!
signal=$PCP_BINADM_DIR/pmsignal
trap "cd $here; rm -rf $tmp.*; exit \$status" 0 1 2 3 15

_seq_store()
{
    echo "--- pcp2zabbix stdout --" >>$seq_full
    $vis $tmp.pcp2zabbix.out >>$seq_full
    echo "--- pcp2zabbix stderr --" >>$seq_full
    $vis $tmp.pcp2zabbix.err >>$seq_full
    echo "--- socat stdout --" >>$seq_full
    $vis $tmp.socat.out >>$seq_full
    echo "--- socat stderr --" >>$seq_full
    $vis $tmp.socat.err >>$seq_full
}

_zbx_header()
{
    output=$1

    # extract the (partially binary) header, preceding the JSON response
    # and make it into a deterministic string (delete everything after the
    # ^A in the header line)
    sed -n 1p $output | \
    sed -e 's/{//g' | \
    od -c | \
    sed -n 1p | \
    tee -a $seq_full | \
    sed -e 's/ D 001.*/ D/g' | \
    sed -e 's/   / /g' -e 's/  / /g'
}

zabbix_port=`_find_free_port`
log="--archive $here/archives/sample-secs"

# real QA test starts here
cat <<EOF >$tmp.config
[options]
zabbix_port = $zabbix_port
zabbix_host = HOSTNAME
zabbix_server = localhost
[globals]
secs = sample.seconds
msecs = sample.milliseconds
EOF

cat $tmp.config >>$seq_full

# start a longer-lived copy of socat we can use for consecutive tests
socat tcp-listen:$zabbix_port,reuseaddr,fork - >>$tmp.socat.out 2>$tmp.socat.err &
pid=$!
sleep 2

echo "== Zabbix Archive ==="
pcp2zabbix -r -t 2 -s 3 $log -c $tmp.config sample >$tmp.pcp2zabbix.out 2>$tmp.pcp2zabbix.err &   # will error out after socket cat dies
pmpid=$!
sleep 2
$signal $pmpid >>$seq_full 2>&1
_seq_store

echo "== Zabbix server input ==="
# check the first line has the initial ZBXD preamble (before JSON)
header=`_zbx_header $tmp.socat.out`
echo "header: $header"
echo "body:"
echo '{' # ate this from the header
sed -n '1!p' $tmp.socat.out
echo #}
# truncate the file so we get separate results for the second run
true > $tmp.socat.out

sleep 2
echo "== Zabbix LLD ==="
pcp2zabbix -r --zabbix-lld -t 2 -s 3 -c $tmp.config sample.float.bin >$tmp.pcp2zabbix.out 2>$tmp.pcp2zabbix.err &
pmpid=$!
sleep 2
$signal $pmpid 2>/dev/null

$signal $pid 2>/dev/null
wait
_seq_store

echo "== Zabbix server input ==="
# check the first line has the initial ZBXD preamble (before JSON)
header=`_zbx_header $tmp.socat.out`
echo "header: $header"
echo "body:"
echo '{' # ate this from the header
# filter out the small non-printable characters (keep \011 [\t],
# \012 [\n] and \015 [\r]) and then due to a potential sample & sleep
# race, we may have more than one sample, pick just the first one
#
tr '\000\001\002\003\004\005\006\007\010\013\014\016\017' '?' <$tmp.socat.out \
| $PCP_AWK_PROG '
BEGIN		{ block = 0 }
/ZBXD/		{ block++
		  if (block > 1) {
		      # close first block, as the second block
		      # starts with a line like }ZBXD...
		      print "}"
		      exit
		  }
		}
NR == 1		{ next }	# header line
		{ print }' \
| sed -e 's,"clock":[0-9]*,"clock":CLOCK,'

# success, all done
status=0
exit
